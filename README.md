# About

CECS2 is a total remaking of my classic [CECS library](https://github.com/terablade2001/CECS) which is now based on C++ 11 (no support for C) and it does uses as internal logging mechanism the [spdlog](https://github.com/gabime/spdlog) library.

The design is to have two configurable sinks for screen and file logging which can configured by the `CECSSingleton`'s sub-sclass `Configuration`. A default setup is shown below.

```C++
  struct Configuration {
    std::string loggerName{"CECS"};
    uint8_t     screenLogLevel{Logger::L::TRC};
    uint8_t     fileLogLevel{Logger::L::NONE};
    std::string logFileName{"CECSLog.log"};
    uint32_t    logFileMaxSizeBytes{100000};
    uint8_t     logFileNumOfRotatingFiles{3};
    std::string logCustomFormatForScreen{"[%^-%L-%$] %v"};
    std::string logCustomFormatForFile{"(%Y-%m-%d %H:%M:%S.%e) [%^-%L-%$] [t:%t] %v"};
    uint8_t     flushLevel{Logger::L::DBG};
    bool        isLoggingUsingModuleNameInsteadOfFilename{true};
    std::string str() const;
  };
```

All the macros are defined in `CECSMacros.hpp` .

## Notes

### Typical functionality

* Logs marked a critical (CRIT) should always lead to program end of execution (program exit).
* The library can be used not only for Errors (ERR/CRIT) logs but also for typical message logs. See `test03_MsgLogging-Macros.cpp` for usage.
  * Such typical message logs can not be of type Critical.
  * Logs can contains module/line information using the `ILog_` macro, or ignore this information using the `HLog_` macro.
* User can switch between ERROR mode and CRITICAL mode. This can be done with the macros `_CECS_MODE_ERR_` and `_CECS_MODE_CRIT_`.
  * In ERROR mode the errors as logged with ERROR level and can be handled / cleared using `_ECSCLS_` related macros (error control).
  * In CRITICAL mode user can not clear the recorded errors and have to lead the execution to termination (exit).
    * This behavior can be overridden by changing the mode to ERROR, then clear the errors and then change back to CRITICAL. However such an action may indicate design issues.
* CECS2 is designed with the aim be compatible with CECS replacement, whenever this is possible.

### Additional functionality - Error Codes

CECS2 provides additional error codes utilities regarding defining, listing and accessing predefined error codes. It does that by introducing new macros ending with `U`, like _ERRTU(), _ERRIU() etc. For documentation the unit tests at `test04_UserErrorCodes-Macros.cpp` can be studied.

The assumption here is that an error should be informed to the client, from an predefined list of errors. This is achieved by building ahead of the execution a map between and error *Tag*, and *ID* and a *Description*, like:

  * Any user-defined error string-Tag like "FILE_CONFIG_OPEN_ERROR"

  * Which is assigned to user-defined integer IDs and Descriptions like:

    * Error-ID: 99
    * Description: "*Failed to open the applications configuration file for reading. Please check the requested configuration file is in the requested path. See logs for more info.*"


CECS2 provides methods to list all the predefined errors which the client of any application can catch and do something with them (error control).

There are two categories of returned errors:

* **AtExit**: Errors returned by program at exit, which should have values between 1 and 127. The above example could be seen as such an error for an application which tries to read a predefined config files, and exits. On exit it will return value 99.
  These errors 

  * 0 generally indicates no error.
  * 1 indicates generic error where the client have either to view the logs to find the issue, or contact support.
    This is generated by all other error capturing macros which have no predefined error Tag (those macros not ending in `U`) 
  * 127 indicates unlisted error, and if it happens it means the code is using a Tag name which is not in the error-list. This is typically a bug from the developer side.

  The value of an *AtExit* recorded error can be acquired with the macro  `_CECS_CODE_ATEXIT_` and can be provided just before the exiting point of the program.

* **OnIntReturn**: Typical error codes outside the range of [0,127].  
  These can be used by developers for typical customized error-control based flows.
  The macro to check if any *OnIntReturn* value has been set is the `_CECS_CODE_ONINTRETURN_`.
  The `_ERRIU()` macro does return this value in it's `return` statement.

